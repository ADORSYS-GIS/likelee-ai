name: Deploy to EC2 (Active on main)

on:
  push:
    branches: [main]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}
  SERVER_IMAGE_NAME: likelee-server
  UI_IMAGE_NAME: likelee-ui
  REMOTE_DIR: /root/likelee/deploy/ec2

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase repository path
        shell: bash
        run: echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push likelee-server
        uses: docker/build-push-action@v6
        with:
          context: .
          file: likelee-server/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ env.REPO_LOWER }}/likelee-server:${{ env.IMAGE_TAG }}
          cache-from: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-server:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-server:buildcache,mode=max

      - name: Build and push likelee-ui
        uses: docker/build-push-action@v6
        with:
          context: .
          file: likelee-ui/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ env.REPO_LOWER }}/likelee-ui:${{ env.IMAGE_TAG }}
          cache-from: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-ui:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-ui:buildcache,mode=max
          build-args: |
            VITE_KEYCLOAK_URL=${{ secrets.VITE_KEYCLOAK_URL }}
            VITE_KEYCLOAK_REALM=${{ secrets.VITE_KEYCLOAK_REALM }}
            VITE_KEYCLOAK_CLIENT_ID=${{ secrets.VITE_KEYCLOAK_CLIENT_ID }}
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
            VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
            VITE_API_BASE_URL=/api
            VITE_AWS_REGION=${{ secrets.VITE_AWS_REGION }}
            VITE_COGNITO_IDENTITY_POOL_ID=${{ secrets.VITE_COGNITO_IDENTITY_POOL_ID }}

  deploy:
    name: Deploy on EC2 via SSH
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Compute lowercase repository path
        shell: bash
        run: |
          echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> "$GITHUB_ENV"

      - name: Upload deploy assets to EC2 (staging in /tmp)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "deploy/ec2"
          target: "/tmp/likelee-deploy"

      - name: Deploy and verify on EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            # Run the remote script with a single-quoted heredoc to avoid any quoting/expansion issues.
            sudo -n bash -lc 'bash -s' <<'REMOTE_SCRIPT'
            set -euo pipefail
            echo "Running deployment as root (user: $(whoami), home: $HOME)"
            # Sync staged assets to target directory under /opt
            mkdir -p "$(dirname "${{ env.REMOTE_DIR }}")"
            mkdir -p "${{ env.REMOTE_DIR }}"

            # Preserve instance-specific files and existing certificates
            if [ -f "${{ env.REMOTE_DIR }}/.env" ]; then cp "${{ env.REMOTE_DIR }}/.env" /tmp/.env.backup || true; fi
            if [ -d "${{ env.REMOTE_DIR }}/letsencrypt" ]; then rm -rf /tmp/letsencrypt.backup && mv "${{ env.REMOTE_DIR }}/letsencrypt" /tmp/letsencrypt.backup || true; fi
            if [ -d "${{ env.REMOTE_DIR }}/certbot-www" ]; then rm -rf /tmp/certbot-www.backup && mv "${{ env.REMOTE_DIR }}/certbot-www" /tmp/certbot-www.backup || true; fi

            # Refresh managed assets (preserve letsencrypt, certbot-www, .env)
            if command -v rsync >/dev/null 2>&1; then
              rsync -a --delete \
                --exclude 'letsencrypt' \
                --exclude 'certbot-www' \
                --exclude '.env' \
                /tmp/likelee-deploy/deploy/ec2/ "${{ env.REMOTE_DIR }}"/
            else
              rm -rf "${{ env.REMOTE_DIR }}"/*
              cp -a /tmp/likelee-deploy/deploy/ec2/. "${{ env.REMOTE_DIR }}"/
            fi

            # Restore preserved files and certificates
            if [ -f /tmp/.env.backup ]; then mv -f /tmp/.env.backup "${{ env.REMOTE_DIR }}/.env"; fi
            if [ -d /tmp/letsencrypt.backup ]; then rm -rf "${{ env.REMOTE_DIR }}/letsencrypt" && mv /tmp/letsencrypt.backup "${{ env.REMOTE_DIR }}/letsencrypt"; fi
            if [ -d /tmp/certbot-www.backup ]; then rm -rf "${{ env.REMOTE_DIR }}/certbot-www" && mv /tmp/certbot-www.backup "${{ env.REMOTE_DIR }}/certbot-www"; fi

            cd "${{ env.REMOTE_DIR }}"
            echo "CWD: $(pwd)"
            echo "Listing deploy directory:" && ls -la

            # Preflight validations
            if [ ! -f docker-compose.yml ]; then
              echo "ERROR: docker-compose.yml not found in $(pwd)" >&2
              exit 1
            fi
            if [ ! -f docker-compose.prod.yml ]; then
              echo "ERROR: docker-compose.prod.yml not found in $(pwd)" >&2
              exit 1
            fi

            # Load DOMAIN and CERTBOT_EMAIL from .env if present
            if [ -f .env ]; then set -a; . ./.env; set +a; fi
            DOMAIN="${DOMAIN:-likelee.ai}"
            CERTBOT_EMAIL="${CERTBOT_EMAIL:-admin@likelee.ai}"
            echo "Using DOMAIN=$DOMAIN CERTBOT_EMAIL=$CERTBOT_EMAIL"
            export DOMAIN CERTBOT_EMAIL
            PROJECT_NAME="likelee"

            # Prepare cert directories
            mkdir -p ./letsencrypt ./certbot-www

            # Bootstrap certificates if missing (standalone mode binds :80)
            if [ ! -f "./letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
              echo "No existing certs found for ${DOMAIN}; obtaining via certbot (standalone)"
              # Stop any container publishing :80 to free the port
              PORT80_IDS=$(docker ps --format '{{.ID}} {{.Ports}}' | awk '/0.0.0.0:80->|:80->/ {print $1}')
              if [ -n "${PORT80_IDS}" ]; then echo "Stopping containers on :80 -> ${PORT80_IDS}"; echo "${PORT80_IDS}" | xargs -r docker stop || true; fi

              if ! docker run --rm -p 80:80 \
                -v "$(pwd)/letsencrypt:/etc/letsencrypt" \
                certbot/certbot:latest certonly --standalone \
                --agree-tos --no-eff-email -m "$CERTBOT_EMAIL" -d "$DOMAIN" \
                --non-interactive --keep-until-expiring; then
                echo "Certbot issuance failed; continuing with any existing certs if present" >&2
              else
                echo "Certbot issuance completed"
              fi
            else
              echo "Certificates already present; skipping issuance"
            fi

            # Determine if certs are available and switch gateway config if not
            if [ ! -f "./letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
              echo "No certs available; switching gateway to HTTP-only"
              cp -f nginx.http.conf nginx.conf || true
              HAS_CERT=0
            else
              HAS_CERT=1
            fi

            # Optional GHCR login if credentials provided
            GHCR_USER="${{ secrets.GHCR_USER }}"
            GHCR_TOKEN="${{ secrets.GHCR_TOKEN }}"
            if [ -n "${GHCR_USER}" ] && [ -n "${GHCR_TOKEN}" ]; then
              echo "Logging into GHCR as ${GHCR_USER}"
              echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin || true
            else
              echo "GHCR_USER/GHCR_TOKEN not set; assuming images are public or host already logged in."
            fi

            export REGISTRY_IMAGE_SERVER="ghcr.io/${{ env.REPO_LOWER }}/likelee-server"
            export REGISTRY_IMAGE_UI="ghcr.io/${{ env.REPO_LOWER }}/likelee-ui"
            export IMAGE_TAG="${{ env.IMAGE_TAG }}"
            # Defensive cleanup: remove any existing containers with fixed names to avoid name conflicts
            docker rm -f likelee-server likelee-ui likelee-gateway >/dev/null 2>&1 || true
            chmod +x scripts/update-images.sh scripts/rollback.sh || true

            if ! ./scripts/update-images.sh; then
              echo "Update step failed; attempting rollback" >&2
              ./scripts/rollback.sh || true
              exit 1
            fi

            if [ -d "./letsencrypt/live/${DOMAIN}" ]; then
              echo "Certificates present:"
              ls -la ./letsencrypt/live/${DOMAIN} || true
            else
              echo "No live certificate directory at ./letsencrypt/live/${DOMAIN}"
            fi

            # Ensure certbot-renew is up (use the same project and directory as the main stack)
            docker compose \
              --project-directory "${{ env.REMOTE_DIR }}" \
              -p "${PROJECT_NAME}" \
              -f docker-compose.yml -f docker-compose.prod.yml up -d certbot-renew || true

            sleep 5
            set +e
            if [ "${HAS_CERT}" = "1" ]; then
              curl -ksS --max-time 10 https://localhost/ >/dev/null
              WEB_OK=$?
              curl -ksS --max-time 10 https://localhost/api/ >/dev/null
              API_OK=$?
            else
              curl -sS --max-time 10 http://localhost/ >/dev/null
              WEB_OK=$?
              curl -sS --max-time 10 http://localhost/api/ >/dev/null
              API_OK=$?
            fi
            set -e

            if [ "$WEB_OK" -ne 0 ] || [ "$API_OK" -ne 0 ]; then
              echo "Health checks failed (WEB=$WEB_OK API=$API_OK); attempting rollback if possible" >&2
              if [ -f ./.state/previous_tag ]; then
                ./scripts/rollback.sh || true
              else
                echo "No previous tag recorded; skipping rollback" >&2
              fi
              exit 1
            fi

            # Verify that the running containers belong to the expected project and tag
            VERIFY_OK=1
            for svc in server ui; do
              CID=$(docker ps -q --filter "label=com.docker.compose.project=${PROJECT_NAME}" --filter "label=com.docker.compose.service=${svc}" | head -n1)
              if [ -z "$CID" ]; then echo "Service ${svc} not running under project ${PROJECT_NAME}" >&2; VERIFY_OK=0; continue; fi
              IMG=$(docker inspect -f '{{.Config.Image}}' "$CID" 2>/dev/null || true)
              echo "Service ${svc} container=$CID image=$IMG"
              case "$IMG" in
                *:"${IMAGE_TAG}") : ;; 
                *) echo "Service ${svc} image tag does not match ${IMAGE_TAG}" >&2; VERIFY_OK=0 ;;
              esac
            done
            if [ "$VERIFY_OK" -ne 1 ]; then
              echo "Image verification failed; attempting rollback if possible" >&2
              if [ -f ./.state/previous_tag ]; then ./scripts/rollback.sh || true; else echo "No previous tag recorded; skipping rollback" >&2; fi
              exit 1
            fi

            echo "Deployment succeeded for tag ${IMAGE_TAG}"
            REMOTE_SCRIPT