name: Deploy to EC2 (Active on main)

on:
  push:
    branches: [main]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}
  SERVER_IMAGE_NAME: likelee-server
  UI_IMAGE_NAME: likelee-ui
  REMOTE_DIR: /root/likelee/deploy/ec2

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Compute lowercase repository path
        shell: bash
        run: echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> "$GITHUB_ENV"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push likelee-server
        uses: docker/build-push-action@v6
        with:
          context: .
          file: likelee-server/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ env.REPO_LOWER }}/likelee-server:${{ env.IMAGE_TAG }}
          cache-from: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-server:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-server:buildcache,mode=max

      - name: Build and push likelee-ui
        uses: docker/build-push-action@v6
        with:
          context: .
          file: likelee-ui/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ env.REPO_LOWER }}/likelee-ui:${{ env.IMAGE_TAG }}
          cache-from: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-ui:buildcache
          cache-to: type=registry,ref=ghcr.io/${{ env.REPO_LOWER }}/likelee-ui:buildcache,mode=max
          build-args: |
            VITE_KEYCLOAK_URL=${{ secrets.VITE_KEYCLOAK_URL }}
            VITE_KEYCLOAK_REALM=${{ secrets.VITE_KEYCLOAK_REALM }}
            VITE_KEYCLOAK_CLIENT_ID=${{ secrets.VITE_KEYCLOAK_CLIENT_ID }}
            VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
            VITE_SUPABASE_ANON_KEY=${{ secrets.VITE_SUPABASE_ANON_KEY }}
            VITE_API_BASE_URL=/api
            VITE_AWS_REGION=${{ secrets.VITE_AWS_REGION }}
            VITE_COGNITO_IDENTITY_POOL_ID=${{ secrets.VITE_COGNITO_IDENTITY_POOL_ID }}

  deploy:
    name: Deploy on EC2 via SSH
    runs-on: ubuntu-latest
    needs: build-and-push
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Compute lowercase repository path
        shell: bash
        run: |
          echo "REPO_LOWER=${GITHUB_REPOSITORY,,}" >> "$GITHUB_ENV"

      - name: Upload deploy assets to EC2 (staging in /tmp)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "deploy/ec2"
          target: "/tmp/likelee-deploy"

      - name: Deploy and verify on EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            sudo -n bash -lc '
              set -euo pipefail
              echo "Running deployment as root (user: $(whoami), home: $HOME)"
              # Sync staged assets to target directory under /opt
              mkdir -p "$(dirname "${{ env.REMOTE_DIR }}")"
              mkdir -p "${{ env.REMOTE_DIR }}"
              # Preserve instance-specific files
              if [ -f "${{ env.REMOTE_DIR }}/.env" ]; then cp "${{ env.REMOTE_DIR }}/.env" /tmp/.env.backup || true; fi
              # Refresh managed assets
              rm -rf "${{ env.REMOTE_DIR }}"/*
              cp -a /tmp/likelee-deploy/deploy/ec2/. "${{ env.REMOTE_DIR }}/"
              # Restore preserved files
              if [ -f /tmp/.env.backup ]; then mv -f /tmp/.env.backup "${{ env.REMOTE_DIR }}/.env"; fi
              cd "${{ env.REMOTE_DIR }}"
              echo "CWD: $(pwd)"
              echo "Listing deploy directory:" && ls -la
              # Preflight validations
              if [ ! -f docker-compose.yml ]; then
                echo "ERROR: docker-compose.yml not found in $(pwd)" >&2
                exit 1
              fi
              if [ ! -f docker-compose.prod.yml ]; then
                echo "ERROR: docker-compose.prod.yml not found in $(pwd)" >&2
                exit 1
              fi
              # Load DOMAIN and CERTBOT_EMAIL from .env if present
              if [ -f .env ]; then set -a; . ./.env; set +a; fi
              DOMAIN="${DOMAIN:-likelee.ai}"
              CERTBOT_EMAIL="${CERTBOT_EMAIL:-admin@likelee.ai}"
              echo "Using DOMAIN=$DOMAIN CERTBOT_EMAIL=$CERTBOT_EMAIL"
              # Prepare cert directories
              mkdir -p ./letsencrypt ./certbot-www
              # Bootstrap certificates if missing (standalone mode binds :80)
              if [ ! -f "./letsencrypt/live/${DOMAIN}/fullchain.pem" ]; then
                echo "No existing certs found for ${DOMAIN}; obtaining via certbot (standalone)"
                # Stop any service on :80 to free the port
                docker ps --format '{{"{{.ID}} {{.Names}} {{.Ports}}"}}' | grep -E '0.0.0.0:80->|:80->' && docker stop likelee-gateway || true
                docker run --rm -p 80:80 \
                  -v "$(pwd)/letsencrypt:/etc/letsencrypt" \
                  certbot/certbot:latest certonly --standalone \
                  --agree-tos --no-eff-email -m "$CERTBOT_EMAIL" -d "$DOMAIN" \
                  --non-interactive --keep-until-expiring
                echo "Certbot issuance completed"
              else
                echo "Certificates already present; skipping issuance"
              fi
              # Optional GHCR login if credentials provided
              GHCR_USER="${{ secrets.GHCR_USER }}"
              GHCR_TOKEN="${{ secrets.GHCR_TOKEN }}"
              if [ -n "${GHCR_USER}" ] && [ -n "${GHCR_TOKEN}" ]; then
                echo "Logging into GHCR as ${GHCR_USER}"
                echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin || true
              else
                echo "GHCR_USER/GHCR_TOKEN not set; assuming images are public or host already logged in."
              fi
              export REGISTRY_IMAGE_SERVER="ghcr.io/${{ env.REPO_LOWER }}/likelee-server"
              export REGISTRY_IMAGE_UI="ghcr.io/${{ env.REPO_LOWER }}/likelee-ui"
              export IMAGE_TAG="${{ env.IMAGE_TAG }}"
              chmod +x scripts/update-images.sh scripts/rollback.sh || true
              if ! ./scripts/update-images.sh; then
                echo "Update step failed; attempting rollback" >&2
                ./scripts/rollback.sh || true
                exit 1
              fi
              echo "Certificates present:"
              ls -la ./letsencrypt/live/${DOMAIN} || true
              # Ensure certbot-renew is up
              docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d certbot-renew || true
              sleep 5
              set +e
              curl -ksS --max-time 10 https://localhost/ >/dev/null
              WEB_OK=$?
              curl -ksS --max-time 10 https://localhost/api/ >/dev/null
              API_OK=$?
              set -e
              if [ "$WEB_OK" -ne 0 ] || [ "$API_OK" -ne 0 ]; then
                echo "Health checks failed (WEB=$WEB_OK API=$API_OK); rolling back" >&2
                ./scripts/rollback.sh || true
                exit 1
              fi
              echo "Deployment succeeded for tag ${IMAGE_TAG}"
            '
